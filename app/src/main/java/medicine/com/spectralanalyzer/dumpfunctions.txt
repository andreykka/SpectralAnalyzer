
    // TODO: 23.03.16 extract this method to external class
    private void findPlace(Wave wave, short[] waves) {
        int start, end;
        List<Pair<Integer, Integer>> periods = new ArrayList<>();
        ShortBuffer sb = ShortBuffer.allocate(waves.length / 2);

        int silence = 3;

        double halfSecondRate = 0.5;

//        Integer allowedSilenceLength = (int) (0.03 * wave.getWaveHeader().getSampleRate());
        Integer allowedSilenceLength = 3; // ms

        Integer silenceCounter = 0;

        int max = 0;
        int period = wave.getWaveHeader().getSampleRate() / 1000 ; // 44100/1000 = 1 ms
        for (int i = 0; i < waves.length; i+=period) {
            max = max < waves[i] ? waves[i] : max;
            if (waves[i] > silence || waves[i] < -silence) {
                sb.put(waves[i]);
                silenceCounter = 0;
            } else {
                if (++silenceCounter < allowedSilenceLength) {
                    sb.put(waves[i]);
                    continue;
                }
                silenceCounter = 0;
                // current i is silence
                if (isLengthEnough(sb.position() * period, wave.getWaveHeader().getSampleRate(), halfSecondRate)) {
                    start = (i - 1) - sb.position() * period;
                    end = sb.position() * period;
                    Pair<Integer, Integer> range = Pair.create(start, end);
                    periods.add(range);
                }
                sb = (ShortBuffer) sb.clear();
            }
        }

        Log.d(TAG, "");

    }

    /**
     * Verify is length of audio segment is bigger than 0.5 sec
     *
     * @return <b>true</b> if length > 0.5 sec, <b>false</b> otherwise.
     */
    // TODO: 23.03.16 extract this method to external class
    private boolean isLengthEnough(Integer sampleCount, Integer sampleRate, Double targetSeconds) {
        double targetSampleCountForTime = sampleRate * targetSeconds;
        return  sampleCount > targetSampleCountForTime;
    }
